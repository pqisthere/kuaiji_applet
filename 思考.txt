1.
    this.setData({
      modalHidden1: !this.data.modalHidden1,
      temptitle: '', // 清空输入框中的内容,不清空下次点开还存有上次的数据
      list: templist
    })

2.
    用templist，temptitle，tempindex在副本上先操作，操作完了再修改实际的原始数据，
    有助于保持原始数据的完整性，不会对页面渲染造成影响

3.
左滑出现重命名、删除按钮
  transform: translateX(180px);
  /* 元素本身的位置不变，但内容区域向右移动了180px */
  触发滑动事件后
  transform: translateX(0);
  再配合动画效果，看起来就像是左滑出现按钮
  有个bug，它原本位置仍然存在

4.
this.data.mainindex 是小程序中页面数据对象（data）中的一个属性，它用于存储当前页面中某个主要项目（main item）的索引值。通常情况下，当需要在页面中处理多个项目时，可以使用 mainindex 来指示当前正在操作的项目的索引。

5.settings.js
// 删除事件
  del: function (e) {
    var index = e.currentTarget.dataset.index;
    var typelist = this.data.list;
    // 从页面数据中删除指定索引的项，这里删除的只是此页面能看到的数据，缓存没删除
    typelist.splice(index, 1);
    // 更新页面数据
    this.setData({
      list: typelist
    });
    console.log('typelist', typelist);
    // 清空缓存数据，这里清空的是用户自定义的数据，因为用户自定义的在此之前已经放到实际的typelist里了，如果不清空，下次新增会把之前删除的所有分类全部加回来，因为你的缓存没有清空
    wx.removeStorageSync('userdeflist');

    // 更新全局的 typelist，不更新的话，如果你删除了全局默认的类型，下次点进来还是保持没删除全局的样子
    app.globalData.typelist = typelist;

    // 提示删除成功
    wx.showToast({
      title: '删除成功',
      icon: 'success',
      duration: 500
    });
  }

  6.detail.js
       for (let i = 0; i < typelist.length; i++) {
        if (i == typeindex) { // 注意这里不能用===，否则无效，===比较值和类型
          typelist[i].selected = true; // 当前点击的位置为true即选中
        } else {
          typelist[i].selected = false; // 其他的位置为false
        }
      }
            // 上面这一段看起来和  selectType: function (e) 里的重复了，但是不可以把他放到  selectType: function (e) 里面，具体原因我也不知道，反正你放个console.log进去，页面打开时，全部按钮都没被选中，console也没有输出任何信息，只有当你点击按钮时，console才会输出信息。我猜想selectType: function (e) 应该是只能点击触发，默认不会触发

7.
修复了点击内容的区域，之前只能点击文字的地方，右边被占据的按钮的位置无法点击，文字和边框之间的padding不可点击。
只需将可点击区域content放在navigator的class里，再将按钮放在navigator里即可，但此时按钮将不再和一条条的数据左右排列，而是会在一条条数据的下面，此时设置子绝父相

8.两个index都涉及遍历列表数据的操作，此时 wx:for="{{list}}" wx:key="index"，wx:key的值不能相同，否则警告

9.不可以吧rename和del按钮都设置为right:0，否则删除按钮覆盖重命名按钮，最终只显示一个按钮

10.
<view class="{{item.isTouchMove ? 'touch-move-active' : ''}}" data-index="{{index}}" bindtouchstart="touchstart" bindtouchmove="touchmove" wx:for="{{list}}" wx:key="index">
渲染账目列表中的每一项

动态设置属性。为true，class为touch-move-active，否则为空字符串。
目的是根据用户是否正在滑动来动态添加或移除样式类，实现滑动时的特效。

data-index属性绑定了当前项的索引值，用于在触发事件时获取当前项的信息。

当用户触摸开始时会触发touchstart事件处理函数 
当用户触摸移动时会触发touchmove事件处理函数

通过wx:for循环渲染账目列表中的每一项
wx:key="index"：指定循环列表中每一项的唯一标识符，使用索引index作为唯一标识符
`wx:key` 是必须的，它用于标识列表中每个项的唯一性，不指定会警告，并导致渲染出错
虽然可能在其他地方没有直接用到 `wx:key`，但在循环渲染列表时，为了保证渲染的正确性和性能，务必要指定 `wx:key`

bug 11.我想让消费日期显示格式为03-31，即去除年份
但是很奇怪，我使用两种方法
①直接在提交表单的时候，就把日期阉割成只有月份和日期，没有年份的，结果最终显示的还是有年份
②在wxml里阉割，结果是所有日期都不见了，年份，月份和日期都不见了

bug 12.修改了setting的消费类型，detail里的并不会实时更新
修复：
原来是onLoad和onShow的问题！！
onLoad只会在第一次进入该页面时加载，此后不会加载
onShow在每次进入页面后都会重新加载
要想让修改后的值实时更新，一定要加onShow


bug 13.重命名模态框点击确认或者取消后，重命名按钮不会回到初始位置（即在屏幕之外）
修复：
  // 重命名模态框-取消
  modalBindcancel2: function () {
    var templist = this.data.list // 获取当前列表数据！！！
    var index = this.data.tempindex // 获取需要重命名的项的索引！！！
    // 将按钮的位置重置为初始位置，此行要写在setData前面！！！
    templist[index].isTouchMove = false;
    this.setData({
      modalHidden2: !this.data.modalHidden2,
      list: templist // ！！！
    })
  },


  bug 14.左滑拉出了删除重命名按钮，然后跳到另一个页面，再返回，按钮还保持被拉出的状态，理想是，跳到另一个页面的时候，按钮全部恢复默认（没拉出）的状态
  解决：

  // index.js
  onShow:function(){
    var list = wx.getStorageSync('cashflow') || []; // 从本地缓存中获取用户现金流数据，如果没有则为空数组
    // 遍历列表项，为每个列表项添加isTouchMove属性，并初始化为false
    list.forEach(function (item) {
      item.isTouchMove = false;
    });
    this.setData({
      list: list
    });
  },

// setting.js
  onShow: function () {
    // 在页面显示时重新将全局数据赋值给data中的list
    var typelist = app.globalData.typelist;
    typelist.forEach(function (item) {
      item.isTouchMove = false; // 将每个元素的isTouchMove属性设置为false
    });
    // 更新页面数据，将处理后的typelist赋值给list
    this.setData({
      list: typelist
    });
    console.log('设置页面onShow', this.data.list);
  },

bug 15.  detail里
    消费了啥，备注的聚焦问题，只有点击输入框的左侧才会有光标闪烁
    解决：
    原来：
      <view class="weui-cell weui-cell_input">
        <input name="title" focus='{{isfocus}}' value='{{subtitle}}' />
      </view>
    改成
    <input class="weui-cell weui-cell_input" name="title" focus='{{isfocus}}' value='{{subtitle}}' />
    原来的input区域只有一小块，修改后，整个单元格都是input区域
